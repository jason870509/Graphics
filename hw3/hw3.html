<!DOCTYPE html>

<html>

<head>
<style>
	body {
	  font-family: Monospace;
	  background-color: #000;
	  color: #fff;
	  margin: 0px;
	  overflow: hidden;
	}

	#info {
    position: absolute;
    top: 2%;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
	}

	#info a,
	.button {
	  color: #f00;
	  font-weight: bold;
	  text-decoration: underline;
	  cursor: pointer
	}


</style>
</head>

<body> 
  <div id="info">
	  <a href="http://threejs.org" target="_blank">three.js</a> - OBJLoader + MTLLoader
    <br>
    <button id="toggle" style="width:20%">Camera Change</button>
	</div>


<script src="https://threejs.org/build/three.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js">
</script>


	
<script>
var camera, scene, renderer, camera1, camera2, change = 0;
var cameraHUD;
var mouseX = 0,
  mouseY = 0;
var keyboard = new KeyboardState();
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;
var controls;
var bs;
var modelName;
var theModel;
var angle = [], x1 = [], y1 = [];
var gcontrols, orbitcontrols;
var pointLight;
var car = [], num = 0;
var theObject;
var pos = new THREE.Vector3();
var speed, angle, vel;
var clock;
var carPlane, tree = [], lastPosition;
init();
animate();

$("#toggle").click(function() {
  if(change == 1) change = 0
  else change ++;
});
(function() {
  Math.clamp = function(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }
})();
class Box2 {
  constructor() {
    this.max = new THREE.Vector3()
    this.min = new THREE.Vector3()
  }
}



function init() {
  clock = new THREE.Clock();
  container = document.createElement('div');
  document.body.appendChild(container);

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);
  renderer.setClearColor (0x888888);

  camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
  camera1.position.z = 100;
  camera1.position.y = 100;

  camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
   camera2.position.z = 50;
   camera2.position.y = 50;
  controls = new THREE.OrbitControls(camera1, renderer.domElement);

  cameraHUD = new THREE.OrthographicCamera(-200, 200, 100, -100, 1, 500);
  cameraHUD.position.set(0, 450, 0)
  cameraHUD.up.set(0, 0, -1) // for top view
  cameraHUD.lookAt(new THREE.Vector3())
  speed = 5.0;
  angle = 0.0;



  //camera2 = 
  // scene

  scene = new THREE.Scene();

  var ambient = new THREE.AmbientLight(0x444444);
  scene.add(ambient);
  orbitcontrols = new THREE.OrbitControls(camera1, renderer.domElement);

  gridxz = new THREE.GridHelper (200, 20,'red','white');
  scene.add (gridxz);
  gridxz.position.y = 8
  //gridxz.rotation.x = Math.PI / 2;
  var directionalLight = new THREE.DirectionalLight(0xffffff);
  directionalLight.position.set(0, 0, 1).normalize();
  scene.add(directionalLight);

  pointLight = new THREE.PointLight (0xffffff);
  pointLight.position.set (100,200,-100);
  scene.add (pointLight);
  //let sphereSize = 3;
  //let pointLightHelper = new THREE.PointLightHelper(pointLight, sphereSize);
  //scene.add(pointLightHelper);
  window.addEventListener('resize', onWindowResize, false);
 


	function onWindowResize() {

	  windowHalfX = window.innerWidth / 2;
	  windowHalfY = window.innerHeight / 2;

	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);

	}
	readModel();
 // renderer.autoClear = false;
 ////////////////////////////////////////////////////////////////////////////
 tree[0] = new THREE.Mesh(new THREE.CylinderGeometry(25, 25, 20, 32), new THREE.MeshBasicMaterial({color:0xff0000}));
 scene.add(tree[0]);
 tree[0].position.set(25, 18, 50)
 tree[1] = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 100, 32), new THREE.MeshBasicMaterial({color:0x333333}));
 scene.add(tree[1]);
 tree[1].position.set(-25, 58, -50)
 tree[2] = new THREE.Mesh(new THREE.CylinderGeometry(15, 15, 50, 32), new THREE.MeshBasicMaterial({color:0xff00ff}));
 scene.add(tree[2]);
 tree[2].position.set(-50, 33, 50)
 carPlane = new THREE.Mesh(new THREE.PlaneGeometry(45, 20), new THREE.MeshBasicMaterial({visible:false, color:0xff00ff}));
  scene.add(carPlane);
  carPlane.rotation.x = - Math.PI/ 2
  carPlane.position.y = 18

}

function readModel (targetSize=40) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  mtlLoader.load('WartHog.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load('WartHog.obj', function(object) {
		
		theObject =  unitize (object, targetSize);
		theObject.add ( new THREE.BoxHelper (theObject) )
		theObject.name = 'OBJ'
		scene.add (theObject);
    console.log(theObject)
    theObject.rotation.z = -Math.PI / 2
    theObject.rotation.x = -Math.PI / 2
    //theObject.position.y = -50
    }, onProgress, onError);

  });

}


////////////////////////////////////////
// wrap an Object3D around the given object
// so that it is centered at +Y axis
// 
function unitize (object, targetSize) {  
	
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (0.5);
	
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	// uniform scaling according to objSize
	var objSize = Math.max (size.x, size.y, size.z);
	var scaleSet = targetSize/objSize;
				
	var theObject1 =  new THREE.Object3D();
	theObject1.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);

	//object.position.set (-center.x*scaleSet, -center.y*scaleSet+5, -center.z*scaleSet);
	return theObject1;
			
}

function animate() {
  requestAnimationFrame(animate);
  orbitcontrols.update();
  if(theObject !== undefined){
      var cameraPos = theObject.localToWorld(new THREE.Vector3(0, -50, 50))
      //camera2.position.set(theObject.position.x, 50, theObject.position.z);
      //camera2.position.copy(cameraPos);
      camera2.lookAt(theObject.position);
      //theObject.position.set(60 * Math.cos(angle), 10, -60 * Math.sin(angle));
      //theObject.rotation.z = angle;
      //angle += 0.01;
      //cameraHUD.position.set (theObject.position.x, 80,theObject.position.z)
      //cameraHUD.up.set (0,0,-1)
      //cameraHUD.lookAt (theObject.position)
      var dt = clock.getDelta();
      update(dt);
      carPlane.position.copy(theObject.position)
      // car updatev
      
      

      R = new Box2()
      console.log(tree[0].geometry.parameters.radiusTop)
      for(i=0;i<tree.length;i++){
        if (coordinateOrigin(carPlane, R, tree[i].position, tree[i].geometry.parameters.radiusTop) != 0){
         // console.log(coordinateOrigin(carPlane, R, tree[0].position, 25))
          //theObject.position.copy(lastPosition)
          speed = -10
          theObject.position.copy(pos);
        }
        else{
          theObject.position.copy(pos);
          theObject.rotation.z = -Math.PI / 2 + angle;
          carPlane.rotation.z = angle;

        }
      }  
          //theObject.position.z = 20
      lastPosition = theObject.position
  }

  render();

}

function render() {
  if (change == 0)
    camera = camera1;
  else
    camera = camera2;
  var WW = window.innerWidth;
  var HH = window.innerHeight;

  renderer.setScissorTest(true);
  
  renderer.setViewport(0, 0, WW, HH);
  camera.aspect = WW / HH;
  camera.updateProjectionMatrix();
  
  renderer.setScissor(0, 0, WW, HH);
  renderer.clear();
  renderer.render(scene, camera);

  renderer.setViewport(WW *4/ 5, HH *2/ 3, WW / 4, HH / 4);
  renderer.setScissor(WW *4/ 5, HH *2/ 3, WW / 4, HH / 4);
  // no need to set aspect (since it is still ONE)
  renderer.clear();  // important!
  renderer.render(scene, cameraHUD);  // border


  
  //   // for top view

  renderer.setScissorTest(false);
  //renderer.render(scene, camera);

}
function update(dt) {
  keyboard.update();
  for (var i = 0; i < 4; i++) {
    //wheels[i].rotation.y = 0
  }
  if (keyboard.pressed("left")) {
    angle += 0.01;
  }
  if (keyboard.pressed("right")) {
    angle -= 0.01;
  }

  if (keyboard.pressed("up")) {
    speed += 0.5;
  }

  if (keyboard.pressed("down")) {
    speed -= 0.5;
  }
  if (keyboard.pressed("space"))
    speed = 0.1
  if (keyboard.pressed("home"))
    speed = 0.1
  speed = Math.clamp(speed, -30.0, 30.0);
  vel = new THREE.Vector3(speed, 0, 0);

  vel.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
  pos.add(vel.clone().multiplyScalar(dt));

}
function check_Intersection(r, c, rad) {
  r.max.x = 45 / 2
  r.max.y = 20 / 2
  r.min.x = r.max.x * -1
  r.min.y = r.max.y * -1
  var rad2 = rad * rad
  r.max.x -= c.x
  r.max.y -= c.y
  r.min.x -= c.x
  r.min.y -= c.y
  //console.log(r)
  if (r.max.x < 0) {
    if (r.max.y < 0) { //left down  1
      if (((r.max.x * r.max.x + r.max.y * r.max.y) < rad2))
        return 1
      return 0
    } else if (r.min.y > 0) { //left up  2
      if (((r.max.x * r.max.x + r.min.y * r.min.y) < rad2))
        return 2
      return 0
      //return ((r.max.x * r.max.x + r.min.y * r.min.y) < rad2)
    } else { //left  3
      if ((Math.abs(r.max.x) < rad))
        return 3
      return 0
      //return (Math.abs(r.max.x) < rad)
    }
  } else if (r.min.x > 0) {
    if (r.max.y < 0) { //right down  4
      if (((r.min.x * r.min.x + r.max.y * r.max.y) < rad2))
        return 4
      return 0
      //return ((r.min.x * r.min.x + r.max.y * r.max.y) < rad2)
    } else if (r.min.y > 0) { //right up  5
      if (((r.min.x * r.min.x + r.min.y * r.min.y) < rad2))
        return 5
      return 0
      //return ((r.min.x * r.min.x + r.min.y * r.min.y) < rad2)
    } else { //right  6
      if ((r.min.x < rad))
        return 6
      return 0
      //return (r.min.x < rad)
    }
  } else {
    if (r.max.y < 0) { //center down  7
      if ((Math.abs(r.max.y) < rad))
        return 7
      return 0
      //return (Math.abs(r.max.y) < rad)
    } else if (r.min.y > 0) { //center up  8
      if ((r.min.y < rad))
        return 8
      return 0
      //return (r.min.y < rad)
    } else //center
      return 9
    //return true
  }

}
function coordinateOrigin(recMesh, r, c, rad) {
  r.max.x = 45 / 2
  r.max.y = 20 / 2
  r.min.x = r.max.x * -1
  r.min.y = r.max.y * -1

  var center = recMesh.position.clone()

  var normalMat = new THREE.Matrix3().getNormalMatrix(recMesh.matrixWorld);

  var xR = new THREE.Vector3(1, 0, 0)
  xR.applyMatrix3(normalMat).normalize()
  var yR = new THREE.Vector3(0, 1, 0)
  yR.applyMatrix3(normalMat).normalize()
  var cSubr = c.clone().sub(center)
  var tmpC = new THREE.Vector3()
  tmpC.x = cSubr.clone().dot(xR)
  tmpC.y = cSubr.clone().dot(yR)
  //console.log(tmpC)
  var p1 = new THREE.Vector2(r.max.x, r.max.y).add(recMesh.position)
  var p2 = new THREE.Vector2(r.min.x, r.max.y).add(recMesh.position)
  var p3 = new THREE.Vector2(r.min.x, r.min.y).add(recMesh.position)
  var p4 = new THREE.Vector2(r.max.x, r.min.y).add(recMesh.position)

  p1.rotateAround(recMesh.position, recMesh.rotation.z)
  p2.rotateAround(recMesh.position, recMesh.rotation.z)
  p3.rotateAround(recMesh.position, recMesh.rotation.z)
  p4.rotateAround(recMesh.position, recMesh.rotation.z)
  var tmp
  var res = check_Intersection(r, tmpC, rad)

  return res
}
</script>
</body>

</html>
